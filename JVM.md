# JVM 知识点



## History

- 1995: Java 正式发布
- 1996: JDK 1.0
- 1997: JDK 1.1。 JDBC, JavaBeans, RMI...
- 1998: JDK 1.2。Java SE EE ME，JIT，Collections
- 1999: Hotspot
- 2000: JDK 1.3。JNDI
- 2002: JDK 1.4。regex, NIO, Log, XML
- 2004: JDK 1.5。自动装箱，泛型，动态注解，枚举，concurrent
- 2006: JDK 1.6。改进JVM，开源，OpenJDK
- 2009: JDK 1.7。Sun -> Oracle，G1
- 2013: JDK 1.8。Lambda, Stream



## JVM



### 内存区域

![](https://static001.geekbang.org/resource/image/ab/77/ab5c3523af08e0bf2f689c1d6033ef77.png?wh=1916*1074)

> 程序计数器

可以看作当前线程所执行字节码文件的行号指示器。多线程情况下，每个线程都有自己独立的计数器，称之为线程私有。

> Java方法栈

也是线程私有的，描述的是Java方法执行的内存模型，每个方法执行时都会创建一个栈帧，用于存储局部变量，操作数栈，动态链接等。

局部变量表存放了编译期可知的各种基本数据类型，对象引用(reference)。局部变量所需的内存空间在编译期完成分配，在方法运行期间是不会改变局部变量表的大小。

> 本地方法栈

与Java方法栈相似，为Native方法服务。

> 堆

被所有线程共享的一块区域，虚拟机启动时创建。

所有对象实例和数组都在这里分配内存。

> 方法区

线程共享，用于存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码等。

> 运行时常量池

方法区的一部分。

用于存放编译期生成的字面量和符号引用，这部分将在类加载进入方法区的运行时常量池中存放。

![](https://static001.geekbang.org/resource/image/5e/3b/5ee351091464de78eed75438b6f9183b.png?wh=1918*1076)

解释执行：将字节码翻译成机器码执行。无需等待编译。

即时编译：将字节码编译成机器码后执行。执行速度更快。

与静态编译相比，JIT拥有程序的运行时信息，并且能根据这个进行优化。







### 对象创建

- new：先去看常量池中是否加载过，没有则执行类加载。

- 加载检查之后，分配内存。

  需要考虑并发情况：一种是**CAS配上失败重试保证更新操作的原子性**。另一种是把内存分配的动作按照线程划分在不同的空间中，即每个线程在Java堆中预先分配一小块内存，成为本地线程分配缓冲（TLAB）

- 内存分配完后，将内存空间初始化为零值。

- 设置对象，包括类的元数据信息，哈希码，对象的GC分代年龄等。这些对象存放在对象头(Object Header)

- 执行<init>

### 对象的内存布局

分为三个区域：对象头，实例数据，对其填充。

> 对象头

包括两部分：

- Mark Word存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有锁等。
- 类型指针，即对象指向它的类元数据的指针，确定是哪个类的实例。

另外，如果对象是一个数组，那对象头中必须有一块用于记录数组长度的指针。

> 实例数据

对象存储的有效信息。

> 对齐填充

Hotspot要求对象的起始地址必须是8字节的整数倍。



### 对象的访问定位

使用对象通过栈上的reference来操作，如何去定位和访问堆中的对象，有两种方式：

- 使用句柄：Java堆中会划分一块内存作为句柄池，reference存储的就是对象的句柄地址，包括实例数据和类型数据的地址信息。
- 直接指针：reference存储的就是对象地址。



```java
String.intern()
// 如果常量池中包含了等于String的字符串，则返回这个对象，否则添加到常量池，并返回对象引用。
```



## 垃圾收集器

### 引用计数法

给对象添加一个引用计数器，每当一个地方引用时，数值加1；引用失效时，数值减一；为0时的对象就不可能再被引用。

问题：无法解决对象循环引用的问题。



### 可达性分析算法

以“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索路径就是引用链，当一个对象到GC Roots没有任何引用链时，则证明这个对象是不可用的。

在Java中，可作为GC Roots的对象包括：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象；
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI引用的对象。



### 引用类型

- 强引用：类似”Object obj = new Object()"，只要强引用还存在，垃圾收集器不会回收掉被引用的存在。
- 软引用：描述一些还有用但非必需的对象，在系统将要发生内存溢出之前，将会把这些对象列进回收范围内进行第二次回收。
- 弱引用：描述非必需对象的，但它的强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾回收前。
- 虚引用：也称幽灵引用，最弱的引用关系。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到的一个系统通知。



一个对象死亡，至少要经历两次标记过程：如果一个对象进行可达性分析后发现没有与GC Roots相连的引用链，那它将会被第一次标记并进行一次筛选，条件是对象是否有必要进行执行finalize()方法。**当对象没有覆盖finalize()或finalize()已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”**。

如果这个对象被判定有必要执行finalize()方法，那么这对象会放置在一个叫F-Queue的队列中，并在稍后一个有虚拟机建立的低优先级的Finalizer线程执行它。



### 回收方法区

永久代的垃圾收集主要包括两部分内容：废弃常量和无用的类。

类需要满足下面三个条件才算是"无用的类"：

- 该类的所有实例都已经被回收。
- 加载该类的ClassLoader以及被回收。
- 该类对象的Class对象没有在任何地方被引用，无法在任何地方通过反射访问。



### 垃圾回收算法

#### 标记-清除算法

最基础的算法，分为两个阶段，首先标记出要回收的对象，在完成标记后统一回收。

不足：

1. 效率问题，标记和清楚的效率都不高；
2. 空间问题，清除之后，会产生大量的内存碎片；



#### 复制算法

将可用内存分为两块，每次只使用其中的一块。

现在的虚拟机都采用这种方法来回收新生代。但不是按1：1来划分内存区域，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间。当回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor空间上，最后清理掉Eden和刚才的Survivor空间。

Hotspot默认Eden和Survivor大小比例是8:1。当Survivor空间不够用时，需要依赖其他内存（老年代）进行分配担保。



#### 标记-整理算法

不直接清除，而是将存活对象向一段移动，最后清理边界外的内存。



#### 分代收集算法

新生代用复制算法；老年代用标记-清理或标记-整理算法。





### Hotspot的算法实现

#### 枚举根节点

Problem：

- 可作为GC Roots 的根节点很多，消耗时间。
- GC停顿，必须在能确保一致性的快照中进行。



##### 准确式GC

Hotspot是使用一组称为OopMap的数据结构，在类加载完成后，Hotspot就把对象内什么偏移量上是什么类型的数据计算出来。在JIT编译过程中，也会在特定位置记录下栈和寄存器中那些位置是引用。



#### 安全点

#### 安全区域



### 垃圾收集器

#### Serial收集器

新生代收集器，单线程收集器，进行垃圾回收时，必须暂停其他所有的工作线程。



#### ParNew收集器

Serial收集器的多线程版本。



#### Parallel Scavenge 收集器

其他收集器关注的是缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge目标则是达到一个可控制的吞吐量。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。即吞吐量 = 运行用户代码时间/（运行用户代码时间+垃圾收集时间）



#### CMS 收集器

Concurrent Mark Sweep，以一种获取最短回收停顿时间为目标的收集器。

基于标记-清除算法。分为4个过程：

- 初始标记（CMS initial mark）
- 并发标记（CMS concurrrent mark）
- 重新标记（CMS remark）
- 并发清除（CMS concurrent sweep）

其中，初始标记，重新标记这两个步骤仍然需要“stop the world”。

初始标记仅仅只是标记GC Roots能关联到的对象；

并发标记就是进行GC Roots Tracing的过程。

重新标记则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。

**缺点：**

- 对CPU资源非常敏感。默认启动的回收线程数是(CPU数量+3)/4，当CPU在4个以上时，并发回收垃圾手机线程不少于25%的CPU资源，并随CPU的数量增加而下降。但当CPu不足4个时，CMS对用户程序的影响可能变得很大。
- 无法处理浮动垃圾。由于CMS并发清理阶段用户线程还在运行，自然会有新的垃圾产生，这一部分垃圾出现在标记过程之后，无法在当次收集中处理掉它们。所以需要预留一部分空间提供并发手机时的程序运作使用。
- 空间碎片。



#### G1 收集器

面向服务端应用的垃圾收集器。

特点：

- 并发与并行：使用多个CPU来缩短停顿的时间。并可以通过并发的方式让用户程序继续执行。
- 分代收集。
- 空间整合：从整体看，是基于标记-整理的。
- 可预测的停顿：建立可预测的停顿时间模型，让使用者明确在一个指定长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

它将整个堆划分成多个大小相等的独立区域（Region），它可以有计划的避免在整个Java堆中进行全区域的垃圾手机。G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表。每次根据允许的收集时间，优先回收价值最大的Region。

在G1收集器中，Region之间的对象引用以及其他收集器中的新生代和老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个Region都有对应的Remembered Set，虚拟机发现程序在对Reference 类型的数据进行写操作时，会产一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中。如果是，就加入到被引用对象所属的Remembered Set当中。



G1收集器的运作大致分为以下几个步骤：

- 初始标记
- 并发标记
- 最终标记
- 筛选回收





## 即时编译器



c1, c2, Graal

> C1

又叫Client编译器，面对的是对启动性能有要求的GUI程序，采用的优化手段相对简单，编译时间较短。

> C2

Server编译器，针对对峰值性能有要求的服务器程序，采用的优化手段较复杂，编译时间较长。生成的代码执行效率较高。



从Java 7开始，Hotspot默认采用分层编译的方式：热点方法首先被C1编译，而后方法中的热点会进一步被C2编译。



## Java基本数据类型

![](https://static001.geekbang.org/resource/image/77/45/77dfb788a8ad5877e77fc28ed2d51745.png?wh=467*278)

> 解释栈帧（interpreted frame）

包括局部变量区，以及字节码的操作数栈。

在Java虚拟机规范中，局部变量区等价于一个数组，并且可以用整数来索引，除了double和long占用两个数组单元，其他基本类型和引用类型占用一个数组单元。

在64位的Hotspot上，int占用8个字节，仅限在局部变量。

Java虚拟机的算术运算基本全依赖于操作数栈。



## 类加载

从class文件到内存中的类，按先后顺序包括加载，链接以及初始化。

> 加载

查找字节流，并根据此创建类的过程。

**启动类加载器**（Bootstrap class loader)：由C++实现。

其他的类加载器都是java.lang.ClassLoader的子类。这些类需要先由Bootstrap 先加载到虚拟机中，才能执行类加载。

双亲委派模型：每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。

ExtClassLoader 负责加载lib/ext下面的类，AppClassLoader负责加载应用程序路径下的类。



> 链接

将创建成的类合并至虚拟机中，分为**验证，准备和解析**。

验证阶段的目的，在于确保被加载类能够满足 Java 虚拟机的约束条件。

准备阶段的目的，则是为被加载类的**静态字段分配内存**。

除了分配内存外，部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。

对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。

解析阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）



> 初始化

在 Java 代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中对其赋值。

如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成**常量值**（ConstantValue），**其初始化直接由 Java 虚拟机完成**。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 **< clinit >**。

类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行 < clinit > 方法的过程。Java 虚拟机会通过**加锁**来确保类的 < clinit > 方法仅被执行一次。

那么，类的初始化何时会被触发呢？JVM 规范枚举了下述多种触发情况：

- 当虚拟机启动时，初始化用户指定的主类；
- 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
- 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
- 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
- 子类的初始化会触发父类的初始化；
- 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
- 使用反射 API 对某个类进行反射调用时，初始化这个类；
- 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。





## JVM如何进行方法调用

### 

### 重载和重写

重载的方法在编译过程中即可完成识别。具体到每一个方法调用，Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：

- 在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；
- 如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；
- 如果在第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。

### JVM 的静态绑定和动态绑定

Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）。前面两个就不做过多的解释了。至于方法描述符，它是由方法的参数类型以及返回类型所构成

因此，在某些文章中，重载也被称为静态绑定（static binding），或者编译时多态（compile-time polymorphism）；而重写则被称为动态绑定（dynamic binding）。

**确切地说，Java 虚拟机中的静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。**

具体来说，Java 字节码中与调用相关的指令共有五种。

- invokestatic：用于调用静态方法。
- invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。
- invokevirtual：用于调用非私有实例方法。
- invokeinterface：用于调用接口方法。
- invokedynamic：用于调用动态方法。



### 调用指令的符号引用

在编译过程中，我们并不知道目标方法的具体内存地址。因此，Java 编译器会暂时用符号引用来表示该目标方法。这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符。

符号引用存储在 class 文件的常量池之中。根据目标方法是否为接口方法，这些引用可分为接口符号引用和非接口符号引用。

对于非接口符号引用，假定该符号引用所指向的类为 C，则 Java 虚拟机会按照如下步骤进行查找。

- 在 C 中查找符合名字及描述符的方法。
- 如果没有找到，在 C 的父类中继续搜索，直至 Object 类。
- 如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。并且，如果目标方法在间接实现的接口中，则需满足 C 与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。

对于接口符号引用，假定该符号引用所指向的接口为 I，则 Java 虚拟机会按照如下步骤进行查找。

- 在 I 中查找符合名字及描述符的方法。
- 如果没有找到，在 Object 类中的公有实例方法中搜索。
- 如果没有找到，则在 I 的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致。

经过上述的解析步骤之后，符号引用会被解析成实际引用。对于可以静态绑定的方法调用而言，**实际引用是一个指向方法的指针**。对于需要动态绑定的方法调用而言，**实际引用则是一个方法表的索引**。



### 方法表

方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。

这些方法可能是具体的、可执行的方法，也可能是没有相应字节码的抽象方法。方法表满足两个特质：其一，子类方法表中包含父类方法表中的所有方法；其二，子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。

实际上，使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作：访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法。相对于创建并初始化 Java 栈帧来说，这几个内存解引用操作的开销简直可以忽略不计。



#### 内联缓存

它能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定。





## JVM 处理异常



在编译生成的字节码中，每个方法都附带一个异常表。异常表中的每一个条目代表一个异常处理器，并且由 **from 指针**、**to 指针**、**target 指针**以及所捕获的异常类型构成。这些指针的值是字节码索引（bytecode index，bci），用以定位字节码。

其中，from 指针和 to 指针标示了该异常处理器所监控的范围，例如 try 代码块所覆盖的范围。target 指针则指向异常处理器的起始位置，例如 catch 代码块的起始位置。

异常实例的构造十分昂贵。这是由于在构造异常实例时，Java 虚拟机便需要生成该异常的栈轨迹（stack trace）。该操作会逐一访问当前线程的 Java 栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常。



## 反射

每个 Method 实例的第一次反射调用都会生成一个委派实现，它所委派的具体实现便是一个本地实现。本地实现非常容易理解。当进入了 Java 虚拟机内部之后，我们便拥有了 Method 实例所指向方法的具体地址。这时候，反射调用无非就是将传入的参数准备好，然后调用进入目标方法。

其实，Java 的反射调用机制还设立了另一种动态生成字节码的实现（下称**动态实现**），直接使用 invoke 指令来调用目标方法。之所以采用委派实现，便是为了能够在**本地实现**以及动态实现中切换。

动态实现和本地实现相比，其运行效率要快上 20 倍 [2] 。这是因为动态实现无需经过 Java 到 C++ 再到 Java 的切换，但由于生成字节码十分耗时，仅调用一次的话，反而是本地实现要快上 3 到 4 倍 [3]。

考虑到许多反射调用仅会执行一次，Java 虚拟机设置了一个阈值 15（可以通过 -Dsun.reflect.inflationThreshold= 来调整），当某个反射调用的调用次数在 15 之下时，采用本地实现；当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程我们称之为 Inflation。



## Java对象的内存布局



在 Java 虚拟机中，每个 Java 对象都有一个对象头（object header），这个由标记字段和类型指针所构成。其中，标记字段用以存储 Java 虚拟机有关该对象的运行数据，如哈希码、GC 信息以及锁信息，而类型指针则指向该对象的类。

在 64 位的 Java 虚拟机中，对象头的标记字段占 64 位，而类型指针又占了 64 位。也就是说，每一个 Java 对象在内存中的额外开销就是 16 个字节。
